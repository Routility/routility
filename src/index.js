import { createHashHistory, createHistory } from 'history';
import { createRecognizer } from 'routility-util';

/**
 * Define route
 *
 * @param {string}            path       Path of current route. This is always relative to parent.
 *                                       E.g. if "/user" is defined as a child of "/home", it will
 *                                       recongnize url of "/home/user"
 * @param {string}            name       Name of current route
 * @param {RouteDefinition[]} [children] Child route
 *
 * @return {RouteDefinition} The RouteDefinition is simply an object with three properties:
 *                           {
 *                           	 path: string;
 *                           	 name: string;
 *                           	 children: RouteDefinition[];
 *                           }
 */
function r(path, name, children = null) {
  return {path, name, children};
}

/**
 * Start listen to route changes
 *
 * @param {Object}          opts
 * @param {RouteDefinition} opts.definition      The definition generated by "r"
 * @param {Object}          opts.handler         Handle browser back or forward button navigation
 *                                               Will be called with new state
 * @param {Object} [opts.browserHistory = false] If true, will use HTML5 push state to update URL
 *
 * @return {navTo} A function to help update current route and get current state
 */
function start({ definition, handler, browserHistory = false }) {
  const recongnize = createRecognizer(definition);
  const history = (browserHistory ? createHistory : createHashHistory)();

  let isActivated = false;
  let currentState;

  history.listen(({pathname, search, action}) => {
    currentState = recongnize(pathname + search);
    if (!isActivated) {
      isActivated = true;
    } else if (action === 'POP') {
      handler(currentState);
    }
  });

  return function (path) {
    if (path == null) {
      return currentState;
    }
    history.push(path);
    // Route change listen handler is sync,
    // so we can return new state within the same run loop
    return currentState;
  };
}

export {
  r,
  start,
};
